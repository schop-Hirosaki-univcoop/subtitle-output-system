# フェーズ 1: 次のステップ

## 現在の状況

### 完了した作業

- ✅ ステップ 1: 実験ブランチ `experiment/vue-cdn` を作成
- ✅ ステップ 2: Vue.js を CDN 経由で導入
- ✅ ステップ 3: 動作確認とコミット
- ✅ ステップ 4: 選択肢 A（実験を続ける）を選択
- ✅ 質問カードの Vue コンポーネント化を実装
- ✅ 動作確認完了（問題なし）

### 実装内容

1. **Vue.js 3.3.4 を CDN から読み込み**
2. **質問カードコンポーネント（QuestionCard）を実装**
   - 既存の HTML 構造（`q-card`クラス）を維持
   - ステータス表示（未送出、送出準備中、送出済）
   - ラジオネーム、ジャンル、質問テキスト、班番号を表示
3. **質問リストコンポーネント（QuestionList）を実装**
   - `app.state.allQuestions`からデータを取得
   - 既存のフィルタリングロジックを適用
   - リアクティブに更新（500ms ごとにチェック）
4. **既存コードとの統合**
   - `window.operatorEmbed.app`から OperatorApp インスタンスを取得
   - 既存のイベントハンドラと統合
   - 既存の`renderQuestions`をラップして共存

## 次のステップの選択肢

### 選択肢 A: さらに実験を続ける（推奨）

**目的:** Vue.js の効果をより実感し、既存コードとの統合方法を学習する

#### 推奨される次の実装

1. **パフォーマンスの最適化**

   - 500ms ごとの更新を、Firebase リスナーやイベントベースの更新に変更
   - 不要な再レンダリングを削減
   - より効率的なデータ更新方法を実装

2. **他の小さな機能を Vue コンポーネント化**

   - ローディング表示を Vue コンポーネント化
   - ステータス表示を Vue コンポーネント化
   - アクションボタンを Vue コンポーネント化

3. **既存コードの段階的な置き換え**
   - `renderQuestions`関数を完全に Vue コンポーネントに置き換え
   - 既存のイベントハンドラを Vue コンポーネントに統合

**メリット:**

- 段階的に移行できる
- フレームワークの効果をより実感できる
- リスクが低い

**デメリット:**

- 時間がかかる
- 実験的なコードが残る可能性がある

### 選択肢 B: フェーズ 2 に進む

**目的:** ビルドツール（Vite）を導入して、本格的な開発環境を構築する

#### 次のステップ

1. **`feature/vite-setup`ブランチを作成**

   ```bash
   git checkout main
   git pull origin main
   git checkout -b feature/vite-setup
   git push -u origin feature/vite-setup
   ```

2. **Vite プロジェクトをセットアップ**

   - TypeScript サポート
   - ホットリロード
   - コード分割と最適化

3. **段階的に移行**
   - 既存コードを Vue コンポーネントに移行
   - ビルドツールの利点を活用

**メリット:**

- 本格的な開発環境を構築できる
- TypeScript サポート
- 最適化とパフォーマンス向上

**デメリット:**

- 学習コストが高い
- セットアップが複雑
- 既存コードとの統合が大規模になる可能性

### 選択肢 C: 実験結果を main ブランチにマージ

**目的:** 実験的な実装を本番環境に反映する（小規模な変更の場合）

#### 次のステップ

1. **Pull Request を作成**

   - `experiment/vue-cdn`から`main`への PR を作成
   - 動作確認の結果を記載
   - レビューを依頼

2. **マージ後の対応**
   - 実験的なコードを整理
   - ドキュメントを更新
   - 次のフェーズを計画

**メリット:**

- 実験結果を本番環境に反映できる
- 段階的な移行が可能

**デメリット:**

- 実験的なコードが本番環境に残る可能性がある
- まだ完全な移行ではない

## 推奨: 選択肢 A（さらに実験を続ける）

**理由:**

1. **パフォーマンスの最適化が重要**

   - 現在の 500ms ごとの更新は非効率的
   - Firebase リスナーやイベントベースの更新に変更することで、より実用的な実装になる

2. **既存コードとの統合方法を学習**

   - より多くの機能を Vue コンポーネント化することで、統合方法を学習できる
   - 段階的な移行の経験を積める

3. **リスクが低い**
   - 実験ブランチで試行錯誤できる
   - うまくいかなければ、簡単に元に戻せる

## 具体的な次のステップ（選択肢 A を選択した場合）

### ステップ 1: パフォーマンスの最適化

**目標:** 500ms ごとの更新を、より効率的な方法に変更

**実装内容:**

1. **Firebase リスナーとの統合**

   - `app.state.allQuestions`の変更を監視
   - 変更があった場合のみ更新

2. **イベントベースの更新**

   - 既存の`renderQuestions`が呼ばれた時に更新
   - カスタムイベントを使用

3. **不要な再レンダリングの削減**
   - Vue の`key`属性を適切に使用
   - コンポーネントのメモ化

### ステップ 2: 他の機能を Vue コンポーネント化

**推奨される実装:**

1. **ローディング表示**

   - シンプルで影響範囲が小さい
   - Vue の条件付きレンダリングを活用

2. **ステータス表示**

   - 質問のステータス（未送出、送出準備中、送出済）を Vue で表示
   - リアクティブな更新を体験

3. **アクションボタン**
   - 既存のアクションボタンを Vue コンポーネント化
   - イベントハンドリングを Vue で管理

### ステップ 3: 既存コードの段階的な置き換え

**目標:** `renderQuestions`関数を完全に Vue コンポーネントに置き換え

**実装内容:**

1. **既存の`renderQuestions`を削除**

   - Vue コンポーネントが完全に機能することを確認
   - 既存のイベントハンドラを Vue コンポーネントに統合

2. **既存のイベントハンドラを Vue コンポーネントに統合**
   - クリックイベント
   - チェックボックスイベント
   - その他のイベント

## 判断フローチャート

```
動作確認完了
    │
    ├─→ さらに実験を続ける？
    │   │
    │   ├─→ はい → 選択肢 A（パフォーマンス最適化、他の機能のコンポーネント化）
    │   │
    │   └─→ いいえ
    │       │
    │       ├─→ フェーズ 2 に進む？ → 選択肢 B（ビルドツール導入）
    │       │
    │       └─→ main にマージ？ → 選択肢 C（実験結果を本番環境に反映）
```

## 次のアクション

**選択肢 A を選択した場合:**

1. パフォーマンスの最適化を実装
2. 他の機能を Vue コンポーネント化
3. 既存コードの段階的な置き換え

**選択肢 B を選択した場合:**

1. `feature/vite-setup`ブランチを作成
2. Vite プロジェクトをセットアップ
3. 段階的に移行

**選択肢 C を選択した場合:**

1. Pull Request を作成
2. レビューを依頼
3. マージ後の対応

---

**作成日**: 2025 年 12 月  
**バージョン**: 1.0.0
