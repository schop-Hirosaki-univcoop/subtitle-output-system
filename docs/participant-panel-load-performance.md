# 参加者リスト管理パネルの読み込み時間が長い原因についての考察

参加者リスト管理パネルの読み込みに時間がかかっている件について、提供いただいたコード（`app.js`, `participants.js`）を分析しました。

主な原因として、「選択中の日程」だけでなく「イベント全体の参加者情報」を一度に取得・処理している点、および初期化時に複数のネットワークリクエストが逐次実行されている点が考えられます。

## 1. 過大なデータ取得と高負荷なクライアント処理

最大のボトルネックは、参加者パネルをロードする際のデータ取得量と、その後の処理内容にある可能性が非常に高いです。

### イベント全体の参加者を取得

`app.js` の `loadParticipants` 関数が実行される際、Firebase から `questionIntake/participants/${eventId}` のパスでデータを取得しています。これは、現在選択している単一の日程（Schedule）のデータではなく、イベント（Event）に紐づくすべての日程の全参加者情報を取得していることを意味します。イベントが大規模になるほど、このダウンロードサイズは肥大化します。

### イベント全体のデータを処理

取得したデータ（イベント全参加者）は、`participants.js` の `normalizeEventParticipantCache` 関数でクライアント側のキャッシュ（`state.eventParticipantCache`）に変換されます。この関数は、取得した巨大なデータ（全スケジュール、全参加者）をループ処理するため、データ量に比例して処理時間がかかります。

### 高負荷な重複チェック処理

最も負荷が高いと推測されるのが、`participants.js` の `updateDuplicateMatches` 関数です。

この関数は、以下の処理を行います：

1. `state.eventParticipantCache`（＝イベント全参加者）をすべて反復処理
2. `state.participants`（＝現在の日程の参加者）も反復処理
3. 「氏名」と「学部学科」をキーにして、現在の日程の参加者一人ひとりについて、イベント全体の他すべての参加者と重複がないかを比較照合

この処理は、イベントの総参加者数と現在の日程の参加者数の掛け算（O(N*M)）に近い計算量になり、参加者が増えると爆発的に処理時間が増加します。これがロード時間を長くしている主犯である可能性が極めて高いです。

## 2. 逐次的なネットワークリクエスト

パネルが表示されるまでの初期化処理（`app.js` の `initAuthWatcher` 内）において、複数のネットワーク通信が**直列（逐次的）**に実行されており、全体の待ち時間を長くしています。

ユーザー認証が完了すると、以下の処理が（多くの場合 `await` で）順番に実行されます：

1. `verifyEnrollment(user)`: ユーザーがスプレッドシートに登録されているか GAS API で確認
2. `ensureAdminAccess()`: Firebase へのアクセス権を確認し、ない場合は GAS API で権限を同期し、`waitForQuestionIntakeAccess` で**意図的な待機（リトライ処理）**を行います
3. `ensureTokenSnapshot(true)`: Firebase から全参加者のトークン情報を取得
4. `loadEvents(...)`: Firebase から全イベント・全日程の基本情報を取得
5. `loadParticipants()`: 上記の「過大なデータ取得」処理を実行
6. `drainQuestionQueue()`: GAS API を呼び出し

これら複数のネットワーク通信が完了するまでローダーが表示され続けるため、各ステップでのわずかな遅延が積み重なり、体感的な読み込み時間を長くしています。

## 3. スプレッドシートへのフォールバック

`loadParticipants` 関数は、もし Firebase にデータが存在しない場合（`!normalized.length`）、GAS API（`action: "fetchQuestionParticipants"`）を呼び出してスプレッドシートからデータを取得しようと試みます。

スプレッドシートからのデータ読み取りは一般的に非常に遅く、このフォールバック処理が発生している場合、それがロード時間の大半を占めている可能性もあります。

## まとめ

参加者パネルのロードが遅い原因は、単一の処理ではなく、以下の要因の組み合わせであると推測されます：

1. **設計**: 単一の日程ではなく、イベント全体の巨大なデータを一括でダウンロードしている
2. **処理**: ダウンロードした全データに対し、クライアント側（ブラウザ）で非常に高負荷な「重複チェック処理」を実行している
3. **通信**: 複数のネットワークリクエスト（Firebase と GAS API）を逐次的に実行しており、待ち時間が累積している

特に**「高負荷な重複チェック処理」と「過大なデータ取得」**がパフォーマンスに最も大きな影響を与えていると考えられます。

## 改善提案

### 短期的な改善

1. **重複チェック処理の最適化**: `updateDuplicateMatches` 関数の計算量を削減（例: ハッシュマップを使用した O(N+M) の実装）
2. **データ取得の最適化**: 現在選択中の日程の参加者のみを取得するように変更（ただし、重複チェックにはイベント全体のデータが必要なため、別途対応が必要）

### 長期的な改善

1. **バックエンドでの重複チェック**: クライアント側ではなく、サーバー側で重複チェックを実行し、結果のみを返す
2. **並列処理**: 可能な限りネットワークリクエストを並列実行し、全体の待ち時間を短縮
3. **データ構造の見直し**: 重複チェックに必要な情報のみを別途保持するなど、データ構造を最適化

## 関連ドキュメント

- `scripts/question-admin/app.js`: 参加者管理のメインロジック
- `scripts/question-admin/participants.js`: 参加者データの正規化と重複チェック処理
- `scripts/question-admin/managers/participant-manager.js`: 参加者管理マネージャー

