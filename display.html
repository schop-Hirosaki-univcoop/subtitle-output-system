<!DOCTYPE html>
<!-- display.html: イベントで表示するテロップ画面の土台を定義し、表示用スクリプトを読み込むページです。 -->
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="referrer" content="same-origin">
  <title>Telop Display</title>
  <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">
  <!-- 主要フォントを先読み（同一オリジン想定） -->
  <link rel="preload" as="font" href="assets/fonts/genei-gothic/GenEiGothicP-Bold.woff2" type="font/woff2" crossorigin>
  <link rel="preload" as="font" href="assets/fonts/genei-gothic/GenEiGothicP-SemiBold.woff2" type="font/woff2" crossorigin>
  <link rel="preload" as="font" href="assets/fonts/genei-gothic/GenEiGothicP-H-KL.woff2" type="font/woff2" crossorigin>
  <style>
    /* === GenEi Gothic P / H-KL を登録（アップ済みの woff2 を使用） === */
    @font-face{
      font-family: "GenEiGothicP";
      src: url("assets/fonts/genei-gothic/GenEiGothicP-ExtraLight.woff2") format("woff2");
      font-weight: 200; font-style: normal; font-display: swap;
    }
    @font-face{
      font-family: "GenEiGothicP";
      src: url("assets/fonts/genei-gothic/GenEiGothicP-Light.woff2") format("woff2");
      font-weight: 300; font-style: normal; font-display: swap;
    }
    @font-face{
      font-family: "GenEiGothicP";
      src: url("assets/fonts/genei-gothic/GenEiGothicP-Regular.woff2") format("woff2");
      font-weight: 400; font-style: normal; font-display: swap;
    }
    @font-face{
      font-family: "GenEiGothicP";
      src: url("assets/fonts/genei-gothic/GenEiGothicP-SemiBold.woff2") format("woff2");
      font-weight: 600; font-style: normal; font-display: swap;
    }
    @font-face{
      font-family: "GenEiGothicP";
      src: url("assets/fonts/genei-gothic/GenEiGothicP-Bold.woff2") format("woff2");
      font-weight: 700; font-style: normal; font-display: swap;
    }
    @font-face{
      font-family: "GenEiGothicP";
      src: url("assets/fonts/genei-gothic/GenEiGothicP-Heavy.woff2") format("woff2");
      font-weight: 900; font-style: normal; font-display: swap;
    }
    /* H-KL（質問本文用）
       → 日本語だけを担当させ、英数字は通常の P にフォールバックさせる */
    @font-face{
      font-family: "GenEiGothicP-HKL";
      src: url("assets/fonts/genei-gothic/GenEiGothicP-H-KL.woff2") format("woff2");
      font-weight: 400; font-style: normal; font-display: swap;
      unicode-range:
        U+3000-303F,      /* CJK記号・句読点 */
        U+3040-309F,      /* ひらがな */
        U+30A0-30FF,      /* カタカナ */
        U+4E00-9FFF,      /* CJK統合漢字 */
        U+FF01-FF60, U+FFE0-FFE6; /* 全角英数・記号 */
    }

    /* ====== Modern look (visual-only) ====== */
    :root{
      --neon-a: #00eaff;    /* シアン系 */
      --neon-b: #ff2a6d;    /* マゼンタ系 */
      --seat-bg1: rgba(4,7,12,.76);   /* 座布団の濃いめグラデ上 */
      --seat-bg2: rgba(3,5,9,.82);    /* 座布団の濃いめグラデ下 */
      --seat-border: rgba(255,255,255,.10);
      --radius: 1vw;
      --shadow: 0 1vw 2vw rgba(0,0,0,.38);
      /* レイアウト用の共通余白（横）と、16:9 に合わせた縦の余白を変数化 */
      --pad-x: 2.5vw;
      --pad-y: calc(var(--pad-x) * (1080 / 1920));
      /* アニメ共通の調整値（現場でCSSだけで調整できるように） */
      --dur-flip: 320ms;
      --ease-flip: cubic-bezier(.25,.9,.2,1);
      --blur-outer: 1vw;
      --side-telop-bg: linear-gradient(135deg, rgba(15, 25, 35, 0.9), rgba(10, 18, 28, 0.92));
      --side-telop-border: rgba(255, 255, 255, 0.2);
      --side-telop-shadow: 0 0.6vw 1.6vw rgba(0, 0, 0, 0.45);
      --side-telop-radius: 1vw;
      --side-telop-padding: 0.65vw 1vw;
      --side-telop-scale: 0.8;
    }
    /* 低負荷モード（?lowgpu=1 で body.low-gpu を付与） */
    .low-gpu {
      --dur-flip: 240ms;
      --blur-outer: .5vw;
    }
    /* 画面下部・全幅・16:9 の #telop-canvas を固定 */
    html, body {
      height: 100%;
      margin: 0;
    }
    #telop-canvas {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      aspect-ratio: 1920 / 1080;   /* 幅から高さを16:9で算出 */
      display: flex;
      flex-direction: column;
      align-items: center;          /* 水平中央（テロップ塊を中央に） */
      justify-content: flex-end;    /* 垂直は下寄せ */
      box-sizing: border-box;
      padding: var(--pad-y) var(--pad-x) var(--pad-y);
      color: #fff;
      font-family: "Noto Sans JP","Hiragino Sans","Meiryo",system-ui,sans-serif;
    }

    /* ─ サイドテロップ（画面上部に常時帯を出す） ─ */
    .side-telops {
      position: absolute;
      inset: var(--pad-y) var(--pad-x) auto var(--pad-x);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1.5vw;
      pointer-events: none;
      z-index: 10;
    }
    .side-telop {
      position: relative;
      z-index: 0;
      min-width: 18vw;
      max-width: 34vw;
      padding: var(--side-telop-padding);
      border-radius: var(--side-telop-radius);
      background: var(--side-telop-bg);
      /* 実枠は透明にしておいて、疑似要素側でグラデ枠を描く */
      border: 0.18vw solid transparent;
      box-shadow: var(--side-telop-shadow);
      backdrop-filter: blur(0.8vw) saturate(140%);
      -webkit-backdrop-filter: blur(0.8vw) saturate(140%);
      color: #f5f7ff;
      font-family: "GenEiGothicP","Noto Sans JP",system-ui,sans-serif;
      font-size: calc((90vw / 42) * var(--side-telop-scale));
      font-weight: 700;
      letter-spacing: .02em;
      line-height: 1.2;
      text-align: center;
      text-shadow:
        0.2vw 0 0 rgba(0,0,0,.45), -0.2vw 0 0 rgba(0,0,0,.45),
        0 0.2vw 0 rgba(0,0,0,.45),  0 -0.2vw 0 rgba(0,0,0,.45),
        0 0 1vw rgba(0,234,255,.15);
      transition: opacity .18s ease, transform .18s ease;
      transform-origin: center;
      overflow: visible;
    }

    /* サイドテロップ用：グラデ枠＋外側グロー */
    .side-telop::before,
    .side-telop::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: calc(var(--side-telop-radius) - 0.1vw);
      pointer-events: none;
    }

    /* 細いグラデーション枠（ネオンチューブ） */
    .side-telop::before {
      padding: 0.14vw; /* 枠の太さ（調整ポイント） */
      background: linear-gradient(135deg, var(--neon-a), var(--neon-b));
      -webkit-mask:
        linear-gradient(#000 0 0) content-box,
        linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
              mask-composite: exclude;
      opacity: .95;
    }

    /* ぼんやり広がる外側グロー */
    .side-telop::after {
      z-index: -1;
      background: linear-gradient(135deg, var(--neon-a), var(--neon-b));
      filter: blur(0.6vw);
      opacity: .1;
      transform: scale(1.03);
    }

    .side-telop.is-empty {
      opacity: 0;
      transform: translateY(-0.6vw) scale(.985);
    }
    .side-telop__label {
      display: block;
      font-size: calc((90vw / 60) * var(--side-telop-scale));
      font-weight: 500;
      opacity: .78;
      letter-spacing: .08em;
      margin-bottom: 0.18vw;
    }
    .side-telop__body {
      display: flex;
      flex-direction: column;
      gap: 0.12vw;
      white-space: normal;
      overflow-wrap: anywhere;
    }
    .side-telop__line {
      display: block;
    }
    .side-telop__line--secondary {
      font-size: 0.8em;
      opacity: .92;
    }
    .side-telop__line--secondary:empty {
      display: none;
    }
    @media (max-width: 1024px){
      .side-telops { inset: 2.2vw; gap: 1vw; }
      .side-telop { min-width: 30vw; font-size: calc(90vw / 38); }
    }

    /* ─ ラジオネーム“タブ座布団” ─ */
    #telop-canvas .name-tag{
      position: absolute;
      top:  calc(-1 * 5vw);
      padding: 0.5vw 1vw 0vw;
      border-radius: 1vw 1vw 0 0;          /* 左上にくっつくインデックス形状 */
      background: rgba(20, 35, 45, 0.90);              /* 現行デザイン踏襲（透明・ガラス感） */
      backdrop-filter: blur(1.2vw);
      -webkit-backdrop-filter: blur(1.2vw);
      border: 0.2vw solid rgba(255,255,255,.18);
      box-shadow:
        0 0 1vw color-mix(in srgb, var(--neon-a, #39f) 65%, transparent),
        0 0 1vw color-mix(in srgb, var(--neon-b, #9f3) 45%, transparent);
      pointer-events: none;                     /* 操作対象ではないため */
      z-index: 1;
      width: fit-content;               /* 内容幅に追従 */
      transform-origin: top left;       /* ← 左端を支点に横伸縮 */
      will-change: transform;
      backface-visibility: hidden;
      transform: translateZ(0);
    }
    
    /* ラッパ（タブ＋本文をまとめてスケール） */
    #telop-canvas .telop-wrap{
      position: relative;
      display: inline-block;
      width:100%;
      transform-origin: bottom center;
      will-change: transform;
      overflow: visible; /* ← タブを外側に“はみ出し”表示するため必須 */
      backface-visibility: hidden;
      transform: translateZ(0); /* 合成レイヤを確実化 */
    }
    /* 本文の座布団（中身だけ） */
    #telop-canvas .telop-box{
      position: relative;
      box-sizing: border-box;          /* ← これが肝心 */
      z-index: 2;
      text-align: left;
      width:100%;
      background: linear-gradient(180deg, var(--seat-bg1), var(--seat-bg2));
      border: 0.2vw solid var(--seat-border);
      border-radius: 0 var(--radius) var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(1vw) saturate(150%);
      -webkit-backdrop-filter: blur(1vw) saturate(150%);
      overflow: hidden;
      padding: 1.3vw;
    }
    /* ネオンの発光する枠線（細い管 + ぼんやりグロー） */
    #telop-canvas .telop-box::before,
    #telop-canvas .telop-box::after{
      content:""; position:absolute; inset:0; border-radius: inherit; pointer-events:none;
      z-index: 0;
    }
    
    /* 細いネオンチューブ（輪郭） */
    #telop-canvas .telop-box::before{
      padding: 1px;                                 /* 細いチューブ */
      background: linear-gradient(135deg, var(--neon-a), var(--neon-b));
      -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      -webkit-mask-composite: xor; mask-composite: exclude;
      opacity: .9;
    }
    
    /* ぼんやり広がるグロー（外側のにじみ） */
    #telop-canvas .telop-box::after{
      background: linear-gradient(135deg, var(--neon-a), var(--neon-b));
      filter: blur(var(--blur-outer));
      opacity: .45;
      transform: scale(1.03);
    }
    
    /* 質問未選択時：ラベルを出さない（保険） */
    #radio-name:empty::before { content: none; }

    /* ─ 表示状態（displayは使わずにアニメ可能にする） ─ */
    #telop-canvas.hidden { opacity: 1; visibility: visible; }
    #telop-canvas.hidden .telop-wrap { opacity: 0; visibility: hidden; pointer-events: none; }
    #telop-canvas.show   { opacity: 1; visibility: visible;  }
    #telop-canvas.hide   { opacity: 1; visibility: visible;  } /* 退場アニメ中 */

    /* 入退場はラッパに対して */
    #telop-canvas.show .telop-wrap{
      animation: telopIn .36s cubic-bezier(.2,.7,.2,1) both;
      will-change: transform, opacity, filter;
    }
    #telop-canvas.hide .telop-wrap{
      animation: telopOut .28s cubic-bezier(.2,.7,.2,1) both;
      will-change: transform, opacity, filter;
    }
    @keyframes telopIn{
      0%   { opacity:0; transform: translateY(1.2vw) scale(.985); filter: blur(0.5vw); }
      60%  { opacity:1; transform: translateY(-0.4vw) scale(1.005); filter: blur(0); }
      100% { opacity:1; transform: translateY(0)    scale(1); }
    }
    @keyframes telopOut{
      0%   { opacity:1; transform: translateY(0)    scale(1);    filter: blur(0); }
      100% { opacity:0; transform: translateY(1vw) scale(.985); filter: blur(0.5vw); }
    }
    @media (prefers-reduced-motion: reduce){
      #telop-canvas.show .telop-box,
      #telop-canvas.hide .telop-box{ animation: none; }
    }

    /* ───────── 内容入替アニメ（テキスト行用） ───────── */
    .text-swap-out{ animation: textOut .18s ease both; }
    .text-swap-in { animation: textIn  .22s ease both; }
    @keyframes textOut{
      0%   { opacity:1; transform: translateY(0);   filter: blur(0); }
      100% { opacity:0; transform: translateY(-0.4vw); filter: blur(0.8vw); }
    }
    @keyframes textIn{
      0%   { opacity:0; transform: translateY(0.5vw); filter: blur(0.8vw); }
      100% { opacity:1; transform: translateY(0);   filter: blur(0); }
    }
    @media (prefers-reduced-motion: reduce){
      .text-swap-out, .text-swap-in{ animation:none !important; }
    }

    /* FLIPはラッパに適用（タブも本文も一緒にスケール） */
    #telop-canvas .telop-wrap{
      transform-origin: bottom center;
      will-change: transform;
    }

    /* 見出し（任意） */
    #radio-name {
      color: #ffffff;
      width: fit-content;
      max-width: 95%;
      /* ラジオネーム本文＝Bold */
      font-family: "GenEiGothicP","Noto Sans JP",system-ui,sans-serif;
      font-weight: 700;
      font-size: calc(90vw / 26);
      line-height: 1.2;
      text-shadow:
        0.2vw 0 0 rgba(0,0,0,.55), -0.2vw 0 0 rgba(0,0,0,.55),
        0 0.2vw 0 rgba(0,0,0,.55),  0 -0.2vw 0 rgba(0,0,0,.55),
        0.2vw 0.2vw 0 rgba(0,0,0,.45), 0.2vw -0.2vw 0 rgba(0,0,0,.45),
        -0.2vw 0.2vw 0 rgba(0,0,0,.45), -0.2vw -0.2vw 0 rgba(0,0,0,.45),
        0 0 1.6vw rgba(0,234,255,.18);
      letter-spacing: .01em;
    }
    #radio-name::before{
      content: "ラジオネーム:";
      font-size: calc(90vw / 36); /* 小さめ */
      margin-right: .5em;
      color: #ffffff;
      opacity: .95;
      font-family: "GenEiGothicP","Noto Sans JP",system-ui,sans-serif;
      font-weight: 400;
    }
    #radio-name.no-label::before{ content:none; }

    .telop-box__inner {
      display: grid;
      grid-template-columns: auto 1fr;
      align-items: start;
    }
    .genre-panel {
      display: flex;
      height:100%;
      flex-direction: column;
      justify-content: center;
      gap: .35vw;
      padding-right: 1vw;
      font-family: "GenEiGothicP","Noto Sans JP",system-ui,sans-serif;
      border-right: 0.18vw solid rgba(255,255,255,.16);
      text-shadow: none;
      margin-block: auto;
    }
    .genre-panel__label {
      font-size: calc(90vw / 44);
      font-weight: 500;
      letter-spacing: .08em;
      color: rgba(255,255,255,.72);
    }
    .genre-panel__value {
      font-size: calc(90vw / 34);
      font-weight: 700;
      color: #ffffff;
      line-height: 1.1;
      letter-spacing: .02em;
      white-space: normal;
      line-break: strict;
      overflow-wrap: anywhere;
    }
    .genre-panel.is-empty {
      display: none;
    }

    /* ─ ここが“1行23文字”の肝 ─*/
    #question {
      position: relative;
      padding-left:1vw;
      z-index: 1;
      width: fit-content;
      max-width: 100%;
      font-family: "GenEiGothicP-HKL","GenEiGothicP","Noto Sans JP",system-ui,sans-serif;
      font-weight: 800;
      font-size: calc(90vw / 23.7);              /* 56–72pxあたりで微調整OK */
      line-height: 1.25;
      letter-spacing: .01em;
      white-space: normal;
      line-break: strict;           /* 日本語の禁則寄り */
      overflow-wrap: anywhere;      /* 英数や句読点が続いても崩れにくく */
      color: #eef;
      text-shadow:
        0.3vw 0 0 rgba(0,0,0,.70),  -0.3vw 0 0 rgba(0,0,0,.70),
        0 0.3vw 0 rgba(0,0,0,.70),   0 -0.3vw 0 rgba(0,0,0,.70),
        0.3vw 0.3vw 0 rgba(0,0,0,.60), 0.3vw -0.3vw 0 rgba(0,0,0,.60),
        -0.3vw 0.3vw 0 rgba(0,0,0,.60), -0.3vw -0.3vw 0 rgba(0,0,0,.60),
        0 0 1vw rgba(0,234,255,.22),
        0 0 1.5vw rgba(255,42,109,.16);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      margin: auto;
    }

    /* プロポーショナル関連の機能を“明示的にON”にする */
    #radio-name,
    #question{
      /* 文字詰め（カーニング）を使う */
      font-kerning: normal;
      /* 東アジア文字をプロポーショナル幅に（'pwid' 相当） */
      /* かなも個別にプロポーショナルにしたいなら追加（'pkna' 相当） */
      font-variant-east-asian: proportional-width proportional-kana;
      /* OpenType 機能を明示（対応フォント・ブラウザで有効） */
      font-feature-settings: "palt" 1, "kern" 1; /* 横組み代替('palt')＋カーニング */
    }

    /* ルビは上に表示（標準）＋ 古い WebKit フォールバック */
    #telop-canvas ruby{
      ruby-position: over;           /* 標準: 上に */
      -webkit-ruby-position: before; /* 旧WebKit: 上に */
    }
    /* 既存サイズ指定はそのまま。line-heightだけ詰めたい時は以下を任意で */
    /* #telop-canvas rt{ line-height:1; } */
    
    /* 入れ替え時に“ふわっ”と表示（任意） */
    .animate-in{ animation: fadeSlideUp .28s ease-out both; }
    @keyframes fadeSlideUp{
      from{ opacity:0; transform: translateY(1.6vw) scale(.995); }
      to  { opacity:1; transform: translateY(0)   scale(1); }
    }
    @media (prefers-reduced-motion: no-preference){
      #telop-canvas .telop-box::after{
        animation: neonPulse 5s ease-in-out infinite;
      }
      @keyframes neonPulse{
        0%, 100% { opacity:.40; }
        15%      { opacity:.48; }
        20%      { opacity:.36; }
        55%      { opacity:.44; }
      }
    }
    rt   {
      font-size: .5em; line-height: 1;
      color:#ffffff;
      -webkit-text-stroke: 0.1vw rgba(0,0,0,.55);
      text-shadow:
        0.15vw 0 0 rgba(0,0,0,.45), -0.15vw 0 0 rgba(0,0,0,.45),
        0 0.15vw 0 rgba(0,0,0,.45),  0 -0.15vw 0 rgba(0,0,0,.45);
    }
    /* 計測用クローンでは一切のモーションを無効化（高さだけ測る） */
    [data-probe],
    [data-probe] * { animation: none !important; transition: none !important; }
    [data-probe] .telop-box::after { content: none !important; }

  </style>
</head>
<body>
  <!-- 表示領域: 画面下部に固定する 16:9 のテロップキャンバス -->
  <div id="telop-canvas">
    <div class="side-telops" aria-live="polite">
      <div id="side-telop-left" class="side-telop" aria-label="サイドテロップ（左）">
        <span class="side-telop__body">
          <span class="side-telop__line side-telop__line--primary"></span>
          <span class="side-telop__line side-telop__line--secondary"></span>
        </span>
      </div>
      <div id="side-telop-right" class="side-telop" aria-label="サイドテロップ（右）">
        <span class="side-telop__label">INFORMATION</span>
        <span class="side-telop__body">
          <span class="side-telop__line side-telop__line--primary"></span>
          <span class="side-telop__line side-telop__line--secondary"></span>
        </span>
      </div>
    </div>
    <!-- テロップラッパ: 名前タグと本文を同時にアニメーションさせる -->
    <div class="telop-wrap">
      <!-- ラジオネーム座布団: 名前の差し替えと入退場を演出 -->
      <div class="name-tag" id="name-tag">
        <span id="radio-name"></span>
      </div>
      <!-- 質問本文: 文言とジャンルラベルを収める本体 -->
      <div class="telop-box">
        <div class="telop-box__inner">
          <div id="genre-panel" class="genre-panel is-empty" aria-live="polite">
            <span class="genre-panel__label" aria-hidden="true">ジャンル</span>
            <span id="genre-label" class="genre-panel__value"></span>
          </div>
          <div id="question" role="status" aria-live="polite"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase スクリプトは既存のまま（IDも同じ） -->
  <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getDatabase, ref, onValue, update, serverTimestamp, get, set, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
        import { getAuth, onAuthStateChanged, signInAnonymously, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getRenderStatePath, getNowShowingPath, getSideTelopPath, parseChannelParams } from "./scripts/shared/channel-paths.js";
        import { info as logDisplayLinkInfo, warn as logDisplayLinkWarn, error as logDisplayLinkError } from "./scripts/shared/display-link-logger.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBh54ZKsM6uNph61QrP-Ypu7bzU_PHbNcY",
            authDomain: "subtitle-output-system-9bc14.firebaseapp.com",
            databaseURL: "https://subtitle-output-system-9bc14-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "subtitle-output-system-9bc14",
            storageBucket: "subtitle-output-system-9bc14.firebasestorage.app",
            messagingSenderId: "378400426909",
            appId: "1:378400426909:web:f1549aad61e3f7aacebd74"
         };

        const app = initializeApp(firebaseConfig);
        const urlSearchParams = new URL(location.href).searchParams;
        // 低負荷モード (?lowgpu=1) を有効化
        if (urlSearchParams.get('lowgpu') === '1') {
          document.body.classList.add('low-gpu');
        }
        const database = getDatabase(app);
        const auth = getAuth(app);

        const initialChannel = parseChannelParams(urlSearchParams);
        const initialEventId = typeof initialChannel.eventId === 'string' ? initialChannel.eventId.trim() : '';
        const initialScheduleId = typeof initialChannel.scheduleId === 'string' ? initialChannel.scheduleId.trim() : '';
        const queryEventPinned = initialEventId.length > 0;
        const querySchedulePinned = queryEventPinned && initialScheduleId.length > 0;
        let channelEventId = queryEventPinned ? initialEventId : '';
        let channelScheduleId = querySchedulePinned ? initialScheduleId : '';
        let renderRef = ref(database, getRenderStatePath(channelEventId, channelScheduleId));
        let nowShowingRef = ref(database, getNowShowingPath(channelEventId, channelScheduleId));
        let sideTelopRef = ref(database, getSideTelopPath(channelEventId, channelScheduleId));
        const displaySessionRef = ref(database, "render/session");
        let nowShowingUnsubscribe = null;
        let sideTelopUnsubscribe = null;
        let displayPresenceRef = null;
        let displayPresenceUid = '';
        let displayPresenceDisconnect = null;

        logDisplayLinkInfo('Display initialized', {
          eventId: channelEventId || null,
          scheduleId: channelScheduleId || null,
          queryEventPinned,
          querySchedulePinned
        });

        refreshSideTelopFallbackFromMeta(channelEventId, channelScheduleId).catch(() => {});

        function setChannel(eventId, scheduleId) {
          const normalizedEvent = typeof eventId === 'string' ? eventId.trim() : '';
          const normalizedSchedule = typeof scheduleId === 'string' ? scheduleId.trim() : '';
          if (normalizedEvent === channelEventId && normalizedSchedule === channelScheduleId) {
            return;
          }
          channelEventId = normalizedEvent;
          channelScheduleId = normalizedSchedule;
          logDisplayLinkInfo('Display channel updated', {
            eventId: channelEventId || null,
            scheduleId: channelScheduleId || null
          });
          renderRef = ref(database, getRenderStatePath(channelEventId, channelScheduleId));
          nowShowingRef = ref(database, getNowShowingPath(channelEventId, channelScheduleId));
          sideTelopRef = ref(database, getSideTelopPath(channelEventId, channelScheduleId));
          subscribeNowShowing();
          subscribeSideTelops();
          syncDisplayPresence('channel-change').catch(() => {});
          refreshSideTelopFallbackFromMeta(channelEventId, channelScheduleId).catch(() => {});
        }

        function applyChannelFromSession(session) {
          if (!session || typeof session !== 'object') {
            return;
          }
          const assignment = session.assignment && typeof session.assignment === 'object' ? session.assignment : null;
          const assignedEventRaw = typeof session.eventId === 'string' ? session.eventId.trim() : '';
          const assignedScheduleRaw = typeof session.scheduleId === 'string' ? session.scheduleId.trim() : '';
          const assignmentEvent = assignment && typeof assignment.eventId === 'string' ? assignment.eventId.trim() : '';
          const assignmentSchedule = assignment && typeof assignment.scheduleId === 'string'
            ? assignment.scheduleId.trim()
            : '';
          const assignedEvent = assignedEventRaw || assignmentEvent;
          const assignedSchedule = assignedScheduleRaw || assignmentSchedule;

          logDisplayLinkInfo('Evaluating display assignment', {
            sessionEvent: assignedEventRaw || null,
            sessionSchedule: assignedScheduleRaw || null,
            assignmentEvent: assignmentEvent || null,
            assignmentSchedule: assignmentSchedule || null,
            queryEventPinned,
            querySchedulePinned
          });

          if (!queryEventPinned) {
            if (assignedEvent) {
              const nextSchedule = querySchedulePinned ? channelScheduleId : assignedSchedule;
              setChannel(assignedEvent, nextSchedule);
            }
            return;
          }

          if (!assignedEvent || assignedEvent !== channelEventId) {
            return;
          }

          if (!querySchedulePinned) {
            setChannel(channelEventId, assignedSchedule);
          }
        }

        let displaySessionUnsubscribe = null;

        function handleDisplaySessionSnapshot(snapshot) {
          const sessionValue = snapshot && typeof snapshot.val === 'function' ? snapshot.val() : null;
          if (!sessionValue || typeof sessionValue !== 'object') {
            return;
          }
          logDisplayLinkInfo('Display session snapshot received', {
            sessionId: typeof sessionValue.sessionId === 'string' ? sessionValue.sessionId : null,
            status: typeof sessionValue.status === 'string' ? sessionValue.status : null,
            expiresAt: typeof sessionValue.expiresAt !== 'undefined' ? sessionValue.expiresAt : null,
            eventId: typeof sessionValue.eventId === 'string' ? sessionValue.eventId : null,
            scheduleId: typeof sessionValue.scheduleId === 'string' ? sessionValue.scheduleId : null
          });
          const currentUser = auth.currentUser || null;
          const currentUid = typeof currentUser?.uid === 'string' ? currentUser.uid.trim() : '';
          const sessionUid = typeof sessionValue.uid === 'string' ? sessionValue.uid.trim() : '';
          if (currentUid && sessionUid && currentUid !== sessionUid) {
            return;
          }
          const assignment = sessionValue.assignment && typeof sessionValue.assignment === 'object'
            ? sessionValue.assignment
            : null;
          const assignmentEvent = typeof assignment?.eventId === 'string' ? assignment.eventId.trim() : '';
          const assignmentSchedule = typeof assignment?.scheduleId === 'string' ? assignment.scheduleId.trim() : '';
          const mergedEvent = typeof sessionValue.eventId === 'string' && sessionValue.eventId.trim()
            ? sessionValue.eventId.trim()
            : assignmentEvent;
          const mergedSchedule = typeof sessionValue.scheduleId === 'string' && sessionValue.scheduleId.trim()
            ? sessionValue.scheduleId.trim()
            : assignmentSchedule;
          sessionInfo = {
            ...(sessionInfo || {}),
            ...sessionValue,
            assignment,
            eventId: mergedEvent,
            scheduleId: mergedSchedule
          };
          applyChannelFromSession(sessionInfo);
          syncDisplayPresence('session-snapshot').catch(() => {});
        }

        function subscribeDisplaySession() {
          if (typeof displaySessionUnsubscribe === 'function') {
            displaySessionUnsubscribe();
          }
          logDisplayLinkInfo('Subscribing display session stream');
          displaySessionUnsubscribe = onValue(displaySessionRef, handleDisplaySessionSnapshot);
        }

        const ID_TOKEN_REFRESH_THRESHOLD_MS = 2 * 60 * 1000;

        function getDisplayPresenceEntryRef(uid) {
          const normalized = typeof uid === 'string' ? uid.trim() : '';
          if (!normalized) {
            return null;
          }
          if (displayPresenceRef && displayPresenceUid === normalized) {
            return displayPresenceRef;
          }
          displayPresenceUid = normalized;
          displayPresenceRef = ref(database, `render/displayPresence/${normalized}`);
          return displayPresenceRef;
        }

        function releaseDisplayPresence() {
          const entryRef = displayPresenceRef;
          const uid = displayPresenceUid;
          const disconnectHandle = displayPresenceDisconnect;
          displayPresenceRef = null;
          displayPresenceUid = '';
          displayPresenceDisconnect = null;
          if (!entryRef || !uid) {
            if (disconnectHandle) {
              disconnectHandle.cancel().catch(() => {});
            }
            return;
          }
          const finalize = () => {
            if (disconnectHandle) {
              disconnectHandle.cancel().catch(() => {});
            }
          };
          remove(entryRef).then(finalize, finalize);
        }

        function registerDisplayPresenceDisconnect(entryRef) {
          if (!entryRef || displayPresenceDisconnect) {
            return;
          }
          try {
            const handle = onDisconnect(entryRef);
            displayPresenceDisconnect = handle;
            handle.remove().catch(() => {});
          } catch (err) {
            logDisplayLinkWarn('Failed to register display presence disconnect', err);
          }
        }

        async function syncDisplayPresence(reason = 'heartbeat') {
          const user = auth.currentUser;
          if (!user || !user.uid) {
            return;
          }
          if (!sessionInfo || !sessionInfo.sessionId) {
            return;
          }
          const entryRef = getDisplayPresenceEntryRef(user.uid);
          if (!entryRef) {
            return;
          }
          try {
            const tokenManager = user.stsTokenManager || {};
            const expiresRaw = tokenManager.expirationTime;
            const expiresAt = typeof expiresRaw === 'number'
              ? expiresRaw
              : typeof expiresRaw === 'string'
                ? Number(expiresRaw)
                : 0;
            const now = Date.now();
            const shouldForceRefresh =
              !latestIdToken || !expiresAt || expiresAt - now <= ID_TOKEN_REFRESH_THRESHOLD_MS;
            const idToken = await user.getIdToken(shouldForceRefresh);
            latestIdToken = idToken;
          } catch (err) {
            logDisplayLinkWarn('Failed to refresh idToken for presence sync', err);
          }
          const assignment = sessionInfo.assignment && typeof sessionInfo.assignment === 'object' ? sessionInfo.assignment : null;
          const payload = {
            uid: user.uid,
            sessionId: sessionInfo.sessionId,
            status: sessionActive ? 'active' : 'pending',
            reason: typeof reason === 'string' ? reason : 'heartbeat',
            updatedBy: 'display',
            version: 'v2',
            clientTimestamp: Date.now(),
            lastSeenAt: serverTimestamp()
          };

          const assignString = (value, key) => {
            if (typeof value !== 'string') {
              return;
            }
            const trimmed = value.trim();
            if (!trimmed) {
              return;
            }
            payload[key] = trimmed;
          };

          assignString(sessionInfo.eventId, 'eventId');
          assignString(sessionInfo.scheduleId, 'scheduleId');
          assignString(assignment?.eventId, 'assignmentEventId');
          assignString(assignment?.scheduleId, 'assignmentScheduleId');
          assignString(channelEventId, 'channelEventId');
          assignString(channelScheduleId, 'channelScheduleId');
          try {
            await set(entryRef, payload);
            registerDisplayPresenceDisconnect(entryRef);
            setSessionActive(true);
          } catch (err) {
            logDisplayLinkWarn('Display presence sync failed', err);
          }
        }

        const GAS_API_URL = 'https://script.google.com/macros/s/AKfycbxYtklsVbr2OmtaMISPMw0x2u0shjiUdwkym2oTZW7Xk14pcWxXG1lTcVC2GZAzjobapQ/exec';

        const HEARTBEAT_INTERVAL_MS = 20000;
        const SESSION_RETRY_DELAY_MS = 8000;

        let sessionInfo = null;
        let sessionActive = false;
        let reportSuppressedLogged = false;
        let pendingRenderUpdate = null;
        let pendingFlushTimer = null;
        let sessionRetryTimer = null;
        let heartbeatTimer = null;
        let latestIdToken = null;
        let beginInFlight = null;

        function clearPendingFlushTimer() {
          if (pendingFlushTimer) {
            clearTimeout(pendingFlushTimer);
            pendingFlushTimer = null;
          }
        }

        function clearSessionRetryTimer() {
          if (sessionRetryTimer) {
            clearTimeout(sessionRetryTimer);
            sessionRetryTimer = null;
          }
        }

        function stopHeartbeat() {
          if (heartbeatTimer) {
            clearInterval(heartbeatTimer);
            heartbeatTimer = null;
          }
        }

        function startHeartbeat(reason = 'session-start') {
          stopHeartbeat();
          heartbeatDisplaySession(reason).catch(err => {
            logDisplayLinkWarn('Display presence bootstrap failed', err);
          });
          heartbeatTimer = setInterval(() => {
            heartbeatDisplaySession('interval').catch(err => {
              logDisplayLinkWarn('Display presence heartbeat failed', err);
            });
          }, HEARTBEAT_INTERVAL_MS);
        }

        function scheduleSessionRetry(delayMs = SESSION_RETRY_DELAY_MS) {
          if (sessionRetryTimer) return;
          sessionRetryTimer = setTimeout(() => {
            sessionRetryTimer = null;
            if (!auth.currentUser) return;
            beginDisplaySession().catch(err => {
              logDisplayLinkError('Display session restart failed', err);
              scheduleSessionRetry(Math.min(delayMs * 1.5, 30000));
            });
          }, delayMs);
        }

        // render_state を更新できるよう、セッション待ちの間は一定間隔で再送をリトライ
        function schedulePendingFlush(delayMs = 5000) {
          if (pendingFlushTimer) return;
          pendingFlushTimer = setTimeout(() => {
            pendingFlushTimer = null;
            if (!pendingRenderUpdate) return;
            if (!sessionActive) {
              scheduleSessionRetry();
              return;
            }
            logDisplayLinkInfo('Retrying deferred render_state update after session resume.');
            flushPendingRender('retry');
          }, delayMs);
        }

        function cloneInfo(info) {
          if (!info) return {};
          try {
            return JSON.parse(JSON.stringify(info));
          } catch (_) {
            return { ...info };
          }
        }

        function resetSessionState() {
          sessionInfo = null;
          sessionActive = false;
          reportSuppressedLogged = false;
          pendingRenderUpdate = null;
          clearPendingFlushTimer();
          clearSessionRetryTimer();
          stopHeartbeat();
          releaseDisplayPresence();
          latestIdToken = null;
          beginInFlight = null;
        }

        async function callGas(action, extra = {}) {
          const user = auth.currentUser;
          if (!user) throw new Error('Not signed in');
          if (!user.isAnonymous) throw new Error('Display authentication must be anonymous');
          const idToken = await user.getIdToken();
          latestIdToken = idToken;
          const res = await fetch(GAS_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({ action, idToken, ...extra })
          });
          let json;
          try {
            json = await res.json();
          } catch (err) {
            throw new Error('Invalid JSON response from GAS');
          }
          if (!json.success) {
            throw new Error(String(json.error || 'GAS request failed'));
          }
          return json;
        }

        function setSessionActive(active) {
          sessionActive = active === true;
          if (sessionActive) {
            reportSuppressedLogged = false;
            flushPendingRender('session ready');
          }
        }

        async function beginDisplaySession() {
          if (beginInFlight) return beginInFlight;
          const user = auth.currentUser;
          if (!user) return;
          beginInFlight = (async () => {
            clearSessionRetryTimer();
            try {
              const result = await callGas('beginDisplaySession');
              if (!result.session || !result.session.sessionId) {
                throw new Error('Invalid session payload');
              }
              sessionInfo = result.session;
              applyChannelFromSession(sessionInfo);
              logDisplayLinkInfo('Display session established', {
                uid: user.uid,
                sessionId: sessionInfo.sessionId
              });
              setSessionActive(true);
              startHeartbeat();
              return sessionInfo;
            } catch (err) {
              setSessionActive(false);
              scheduleSessionRetry();
              throw err;
            } finally {
              beginInFlight = null;
            }
          })();
          return beginInFlight;
        }

        async function heartbeatDisplaySession(reason = 'heartbeat') {
          if (!sessionInfo || !sessionInfo.sessionId) {
            await beginDisplaySession();
            return;
          }
          try {
            await syncDisplayPresence(reason);
          } catch (err) {
            logDisplayLinkWarn('Display presence heartbeat error', err);
          }
        }

        async function endDisplaySession(reason) {
          if (!sessionInfo || !sessionInfo.sessionId) return;
          try {
            await callGas('endDisplaySession', { sessionId: sessionInfo.sessionId, reason });
          } catch (err) {
            logDisplayLinkWarn('Failed to end display session', err);
          } finally {
            releaseDisplayPresence();
          }
        }

        function sendSessionEndBeacon(reason) {
          if (!sessionInfo || !sessionInfo.sessionId || !latestIdToken) return false;
          try {
            const payload = JSON.stringify({
              action: 'endDisplaySession',
              idToken: latestIdToken,
              sessionId: sessionInfo.sessionId,
              reason: reason || 'beacon'
            });
            const blob = new Blob([payload], { type: 'application/json' });
            return navigator.sendBeacon(GAS_API_URL, blob);
          } catch (err) {
            logDisplayLinkWarn('sendBeacon failed', err);
            return false;
          }
        }

        onAuthStateChanged(auth, async (user) => {
          if (!user) {
            resetSessionState();
            signInAnonymously(auth).catch(err => {
              logDisplayLinkError('Anonymous sign-in failed', err);
            });
            return;
          }

          if (!user.isAnonymous) {
            logDisplayLinkWarn('Non-anonymous user detected on display; re-authenticating anonymously.');
            resetSessionState();
            try {
              await signOut(auth);
            } catch (err) {
              logDisplayLinkError('Failed to sign out non-anonymous user', err);
            }
            return;
          }

          beginDisplaySession().catch(err => {
            logDisplayLinkError('Failed to establish display session', err);
          });
        });

        window.addEventListener('pagehide', () => {
          sendSessionEndBeacon('pagehide');
          stopHeartbeat();
          releaseDisplayPresence();
        });

        window.addEventListener('beforeunload', () => {
          sendSessionEndBeacon('beforeunload');
          stopHeartbeat();
          releaseDisplayPresence();
        });

        window.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            sendSessionEndBeacon('hidden');
          }
        });

        subscribeNowShowing();
        subscribeSideTelops();
        subscribeDisplaySession();

        function flushPendingRender(reason) {
          if (!pendingRenderUpdate) return;
          if (!sessionActive) {
            scheduleSessionRetry();
            return;
          }
          const pending = pendingRenderUpdate;
          if (reason === 'retry') {
            logDisplayLinkInfo('Flushing deferred render_state update (scheduled retry).');
          } else if (reason) {
            logDisplayLinkInfo(`Flushing deferred render_state update (${reason}).`);
          } else {
            logDisplayLinkInfo('Flushing deferred render_state update.');
          }
          pendingRenderUpdate = null;
          writeRenderState(pending.phase, pending.info, { force: true });
        }

        function writeRenderState(phase, info = {}, { force = false } = {}) {
          if (!force && !sessionActive) {
            pendingRenderUpdate = { phase, info: cloneInfo(info) };
            if (!reportSuppressedLogged) {
              logDisplayLinkInfo('render_state update deferred until display session is active.');
              reportSuppressedLogged = true;
            }
            schedulePendingFlush(2000);
            beginDisplaySession().catch(() => {});
            return Promise.resolve();
          }

          const payload = {
            phase,
            updatedAt: serverTimestamp(),
            ...info
          };

          return update(renderRef, payload).then(() => {
            pendingRenderUpdate = null;
            clearPendingFlushTimer();
            reportSuppressedLogged = false;
            setSessionActive(true);
          }).catch(err => {
            if (err && err.code === 'PERMISSION_DENIED') {
              pendingRenderUpdate = { phase, info: cloneInfo(info) };
              setSessionActive(false);
              logDisplayLinkWarn('render_state update denied; retrying after session renewal.', err);
              schedulePendingFlush();
              scheduleSessionRetry();
              return;
            }
            logDisplayLinkError('render_state update failed', err);
          });
        }

        // ★ 状態レポート（display → Firebase）
        function reportRender(phase, info = {}) {
          return writeRenderState(phase, info);
        }
    
        const radioNameEl = document.getElementById('radio-name');
        const questionEl = document.getElementById('question');
        const genrePanelEl = document.getElementById('genre-panel');
        const genreValueEl = document.getElementById('genre-label');
        const telopCanvas = document.getElementById('telop-canvas');

        const sideTelopLeftEl = document.getElementById('side-telop-left');
        const sideTelopRightEl = document.getElementById('side-telop-right');
        const sideTelopLeftBodyEl = sideTelopLeftEl?.querySelector('.side-telop__body');
        const sideTelopRightBodyEl = sideTelopRightEl?.querySelector('.side-telop__body');

        const urlSideLeft = (urlSearchParams.get('sideLeft') ?? urlSearchParams.get('sideL') ?? '').trim();
        const urlSideRight = (urlSearchParams.get('sideRight') ?? urlSearchParams.get('sideR') ?? '').trim();
        const defaultEventName = (urlSearchParams.get('eventName') ?? urlSearchParams.get('eventLabel') ?? '').trim();
        const defaultScheduleLabel = (urlSearchParams.get('scheduleLabel') ?? '').trim();
        const defaultScheduleDate = (urlSearchParams.get('scheduleDate') ?? urlSearchParams.get('date') ?? '').trim();
        const defaultScheduleTime = (urlSearchParams.get('scheduleTime') ?? urlSearchParams.get('time') ?? '').trim();
        const defaultScheduleText = defaultScheduleLabel
          || [defaultScheduleDate, defaultScheduleTime].filter(Boolean).join(' ');
        const inferredSideLeft = [defaultEventName, defaultScheduleText]
          .filter(Boolean)
          .join('\n');

        const sideTelopDefaults = {
          left: urlSideLeft || inferredSideLeft,
          right: urlSideRight || 'まずは自己紹介です・・・'
        };
        const sideTelopState = {
          fallback: sideTelopDefaults,
          active: { ...sideTelopDefaults }
        };
        let sideTelopMetaToken = 0;

        function ensureString(value) {
          return typeof value === 'string' ? value.trim() : '';
        }

        const telopWrap = document.querySelector('#telop-canvas .telop-wrap');
        const telopBox  = document.querySelector('#telop-canvas .telop-box');
        const nameTagEl = document.getElementById('name-tag');
    
        // 初期状態は非表示に（データ到着まで）
        telopCanvas.classList.add('hidden');
    
        // 表示/非表示の制御ヘルパ
        // ★ レース対策トークン
        let __updateToken = 0;
        let __currentToken = 0;

        async function showTelop(next){
          const token = (++__updateToken || 1);
          __currentToken = token;
          const showingPayload = { name: next?.name || '', question: next?.question || '' };
          if (next?.genre) showingPayload.genre = next.genre;
          if (next?.uid) showingPayload.uid = String(next.uid);
          if (next?.participantId) showingPayload.participantId = String(next.participantId);
          if (next?.pickup) showingPayload.pickup = true;
          reportRender('showing');
          try{
            if (__currentToken !== token) return;
            await flipResize(next);
            if (__currentToken !== token) return;
            const visiblePayload = { name: next?.name || '', question: next?.question || '' };
            if (next?.genre) visiblePayload.genre = next.genre;
            if (next?.uid) visiblePayload.uid = String(next.uid);
            if (next?.participantId) visiblePayload.participantId = String(next.participantId);
            if (next?.pickup) visiblePayload.pickup = true;
            await reportRender('visible');
          } catch(e){
            logDisplayLinkError('Failed to show telop', e);
            await reportRender('error', { error: String(e && e.message || e) });
            // ★ 自動復帰：5秒後に hidden へ
            setTimeout(async () => {
              if (__currentToken === token) {
                try { await reportRender('hidden'); } catch(_) {}
              }
            }, 5000);
            return;
          }
          // 念のため：テキストは必ず可視状態に戻し、高さロックも解除してから入場
          ensureTextVisible();
          telopWrap.style.transform = '';
          telopWrap.style.transition = '';
          telopCanvas.classList.remove('hidden','hide');
          void telopCanvas.offsetWidth;            // アニメ再起動
          telopCanvas.classList.add('show');
        }
        async function hideTelop(){
          const token = (++__updateToken || 1);
          __currentToken = token;
          reportRender('hiding');
          try{
            if (__currentToken !== token) return;
            await buildOut();
            if (__currentToken !== token) return;
            // ビルドアウト完了時：中身もクリアしたいので nowShowing を null に
            await reportRender('hidden', { nowShowing: null });
          } catch(e){
            logDisplayLinkError('Failed to hide telop', e);
            await reportRender('error', { error: String(e && e.message || e) });
            setTimeout(async () => {
              if (__currentToken === token) {
                try { await reportRender('hidden'); } catch(_) {}
              }
            }, 5000);
          }
        }
        // 入退場アニメ終了時の後始末
        let pendingClear = false;
        telopWrap?.addEventListener('animationend', (e)=>{
          if (e.animationName === 'telopIn'){
            // 入場アニメの transform をクリア（以降の FLIP と競合させない）
            telopCanvas.classList.remove('show');
          }
          if (e.animationName === 'telopOut'){
            telopCanvas.classList.add('hidden');
            telopCanvas.classList.remove('hide');
            if (pendingClear){
              radioNameEl.textContent = '';
              genreValueEl.textContent = '';
              genrePanelEl.classList.add('is-empty');
              questionEl.innerHTML = '';
              radioNameEl.classList.remove('no-label');
              prevName = ''; prevQuestion = ''; prevGenre = '';
              pendingClear = false;
            }
          }
        });
    
        // アニメの取りこぼし防止（animationend が飛ばなくても確実に進む）
        function fadeOut(el){
          el.classList.remove('text-swap-in','text-swap-out');
          void el.offsetWidth; el.classList.add('text-swap-out');
          return new Promise((resolve)=>{
            const done = ()=> resolve();
            el.addEventListener('animationend', done, { once:true });
            setTimeout(done, 280); // フォールバック
          });
        }
        function fadeIn(el){
          el.classList.remove('text-swap-out');
          void el.offsetWidth; el.classList.add('text-swap-in');
          const cleanup = ()=> el.classList.remove('text-swap-in');
          el.addEventListener('animationend', cleanup, { once:true });
          setTimeout(cleanup, 320); // フォールバック
        }
    
        // 念のため：強制的に可視へ戻すユーティリティ
        function ensureTextVisible(){
          [radioNameEl, genrePanelEl, questionEl].forEach(el=>{
            el.classList.remove('text-swap-out','text-swap-in');
            el.style.opacity = ''; // カスタムで触っていればリセット
          });
        }

        // ★ 退場アニメ（.hide を付けて telopOut の終了を待つ）
        function buildOut(){
          return new Promise((resolve)=>{
            // すでに hidden なら何もしない
            if (telopCanvas.classList.contains('hidden')) { resolve(); return; }
            // 入場状態を外し、退場を開始
            telopCanvas.classList.remove('show');
            void telopCanvas.offsetWidth; // reflow でアニメ再始動を安定化
            telopCanvas.classList.add('hide');

            let settled = false;
            const onEnd = (e)=>{
              if (e.animationName !== 'telopOut') return;
              telopWrap.removeEventListener('animationend', onEnd);
              settled = true;
              resolve();
            };
            telopWrap.addEventListener('animationend', onEnd);
            // フォールバック（アニメイベント取りこぼし対策）
            setTimeout(()=>{
              if (!settled){
                telopWrap.removeEventListener('animationend', onEnd);
                resolve();
              }
            }, 450);
          });
        }
    
        /* ===== FLIP（scaleY）で“現在→目標”にだけ補間：超なめらか ===== */
        function applyTexts(next){
          // ラベル制御 → テキストの順で（疑似要素の有無が高さに効くため）
          radioNameEl.classList.toggle('no-label', next.noLabel);
          radioNameEl.textContent = next.name || '';
          const genreText = (next.genre || '').trim();
          genreValueEl.textContent = genreText;
          genrePanelEl.classList.toggle('is-empty', !genreText);
          questionEl.innerHTML    = applyRuby(next.question || '');
        }
        async function fontsReady(){
          if (!document.fonts) return;
          if (document.fonts.status === 'loaded') return;
          await Promise.race([
            document.fonts.ready.catch(()=>{}),
            new Promise(res=>setTimeout(res,1500))
          ]);
        }
        // FLIP：ラッパ（タブ＋本文）を scaleY、タブを scaleX で滑らかに補間
        function flipResize(next){
          const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
          const firstH = telopWrap.offsetHeight | 0;   // いまの見た目高さ（タブ含む）
          const firstW = nameTagEl.offsetWidth | 0;    // いまのタブ幅
          applyTexts(next);                             // ← 先に最終内容へ（レイアウト確定）
          void telopWrap.offsetHeight;                 // reflow
          const lastH  = telopWrap.offsetHeight | 0;   // 最終高さ
          const lastW  = nameTagEl.offsetWidth | 0;    // 最終タブ幅

          const doH = (!!firstH && !!lastH && Math.abs(lastH - firstH) >= 2);
          const doW = (!!firstW && !!lastW && Math.abs(lastW - firstW) >= 2);
          if (reduce || (!doH && !doW)) return Promise.resolve();

          if (doH){
            telopWrap.style.transition = 'none';
            telopWrap.style.transform  = `scaleY(${firstH / lastH})`;
          }
          if (doW){
            nameTagEl.style.transition = 'none';
            nameTagEl.style.transform  = `scaleX(${firstW / lastW})`;
          }
          // transform を同フレーム適用（チラつき防止）
          void getComputedStyle(telopWrap).transform;
          void getComputedStyle(nameTagEl).transform;

          return new Promise(resolve=>{
            requestAnimationFrame(()=>{
              requestAnimationFrame(()=>{
                const tr = `transform var(--dur-flip) var(--ease-flip)`;
                let pending = 0;
                const cleanup = ()=>{
                  if (doH){ telopWrap.style.transition=''; telopWrap.style.transform=''; }
                  if (doW){ nameTagEl.style.transition=''; nameTagEl.style.transform=''; }
                  resolve();
                };
                const done = ()=>{ if(--pending<=0) cleanup(); };
                if (doH){
                  pending++;
                  telopWrap.style.transition = tr;
                  telopWrap.style.transform  = 'scaleY(1)';
                  telopWrap.addEventListener('transitionend', done, {once:true});
                }
                if (doW){
                  pending++;
                  nameTagEl.style.transition = tr;
                  nameTagEl.style.transform  = 'scaleX(1)';
                  nameTagEl.addEventListener('transitionend', done, {once:true});
                }
                setTimeout(cleanup, 450); // フォールバック
              });
            });
          });
        }
  
        let prevName = '', prevQuestion = '', prevGenre = '';
        // 連続更新の競合防止用トークン
        let updateToken = 0;
    
        function normalizeDictionarySnapshot(value){
          const list = Array.isArray(value)
            ? value
            : value && typeof value === 'object'
              ? Object.values(value)
              : [];
          return list
            .map(item => {
              const term = String(item?.term ?? '').trim();
              const ruby = String(item?.ruby ?? '').trim();
              const enabledValue = item?.enabled;
              let enabled = true;
              if (typeof enabledValue === 'boolean') {
                enabled = enabledValue;
              } else if (typeof enabledValue === 'string') {
                enabled = enabledValue.trim().toLowerCase() !== 'false';
              } else if (typeof enabledValue === 'number') {
                enabled = enabledValue !== 0;
              }
              return { term, ruby, enabled };
            })
            .filter(entry => entry.enabled && entry.term && entry.ruby)
            .map(({ term, ruby }) => ({ term, ruby }));
        }

        let dictionary = [];
        const dictRef = ref(database, 'dictionary');
        onValue(dictRef, snap => { dictionary = normalizeDictionarySnapshot(snap.val()); });
        
        // テキストにルビを適用する関数
        function applyRuby(text) {
            if (!text) return '';
            const base = document.createElement('div');
            base.textContent = String(text);
            const entries = Array.isArray(dictionary) ? dictionary : [];
            if (!entries.length) {
              return base.innerHTML;
            }

            entries.sort((a, b) => b.term.length - a.term.length);
            const patternSource = entries.map(entry => escapeRegExp(entry.term)).join('|');
            if (!patternSource) {
              return base.innerHTML;
            }
            const entryMap = new Map();
            entries.forEach(entry => {
              if (!entryMap.has(entry.term)) entryMap.set(entry.term, entry);
            });

            const walker = document.createTreeWalker(base, NodeFilter.SHOW_TEXT);
            const textNodes = [];
            while (walker.nextNode()) {
              textNodes.push(walker.currentNode);
            }

            for (const node of textNodes) {
              const value = node.nodeValue;
              if (!value) continue;
              const regex = new RegExp(patternSource, 'g');
              let match;
              let lastIndex = 0;
              const frag = document.createDocumentFragment();
              while ((match = regex.exec(value)) !== null) {
                const { index } = match;
                if (index > lastIndex) {
                  frag.appendChild(document.createTextNode(value.slice(lastIndex, index)));
                }
                const matchedText = match[0];
                const entry = entryMap.get(matchedText);
                if (entry) {
                  const rubyEl = document.createElement('ruby');
                  rubyEl.appendChild(document.createTextNode(matchedText));
                  const rtEl = document.createElement('rt');
                  rtEl.textContent = entry.ruby;
                  rubyEl.appendChild(rtEl);
                  frag.appendChild(rubyEl);
                } else {
                  frag.appendChild(document.createTextNode(matchedText));
                }
                lastIndex = index + matchedText.length;
              }
              if (lastIndex === 0) continue; // 置換なし
              if (lastIndex < value.length) {
                frag.appendChild(document.createTextNode(value.slice(lastIndex)));
              }
              node.replaceWith(frag);
            }

            return base.innerHTML;
        }
        
        function escapeHtml(s){
          return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
                          .replace(/"/g,'&quot;').replace(/'/g,'&#039;');
        }        

        // 正規表現用の特殊文字をエスケープするヘルパー関数
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function setSideTelop(el, bodyEl, text){
          const content = String(text || '').trim();
          const primaryEl = bodyEl?.querySelector('.side-telop__line--primary');
          const secondaryEl = bodyEl?.querySelector('.side-telop__line--secondary');

          const lines = content.length ? content.split(/\r?\n/).map(l => l.trim()).filter(Boolean) : [];
          const primaryText = lines[0] || '';
          const secondaryText = lines.slice(1).join(' ') || '';

          if (primaryEl) primaryEl.textContent = primaryText;
          if (secondaryEl) secondaryEl.textContent = secondaryText;
          if (el) el.classList.toggle('is-empty', !(primaryText || secondaryText));
        }

        function resolveSideTelopValue(value, fallback){
          if (typeof value === 'undefined') return fallback;
          const normalized = String(value ?? '').trim();
          return normalized || fallback;
        }

        function updateSideTelopFallback({ left, right } = {}) {
          const prevFallback = { ...sideTelopState.fallback };
          const normalizedLeft = ensureString(left);
          const normalizedRight = ensureString(right);
          sideTelopState.fallback = {
            left: typeof left === 'undefined' || !normalizedLeft ? prevFallback.left : normalizedLeft,
            right: typeof right === 'undefined' || !normalizedRight ? prevFallback.right : normalizedRight
          };

          const payload = {};
          if (sideTelopState.active.left === prevFallback.left) {
            payload.sideTelopLeft = sideTelopState.fallback.left;
          }
          if (sideTelopState.active.right === prevFallback.right) {
            payload.sideTelopRight = sideTelopState.fallback.right;
          }

          if (Object.keys(payload).length > 0) {
            applySideTelops(payload);
          }
        }

        function applySideTelops(payload = {}) {
          const hasLeft = Object.prototype.hasOwnProperty.call(payload, 'sideTelopLeft')
            || Object.prototype.hasOwnProperty.call(payload, 'sideLeft');
          const hasRight = Object.prototype.hasOwnProperty.call(payload, 'sideTelopRight')
            || Object.prototype.hasOwnProperty.call(payload, 'sideRight');

          const leftRaw = Object.prototype.hasOwnProperty.call(payload, 'sideTelopLeft')
            ? payload.sideTelopLeft
            : payload.sideLeft;
          const rightRaw = Object.prototype.hasOwnProperty.call(payload, 'sideTelopRight')
            ? payload.sideTelopRight
            : payload.sideRight;

          const nextLeft = resolveSideTelopValue(hasLeft ? leftRaw : undefined, sideTelopState.fallback.left);
          const nextRight = resolveSideTelopValue(hasRight ? rightRaw : undefined, sideTelopState.fallback.right);

          sideTelopState.active = { left: nextLeft, right: nextRight };
          setSideTelop(sideTelopLeftEl, sideTelopLeftBodyEl, nextLeft);
          setSideTelop(sideTelopRightEl, sideTelopRightBodyEl, nextRight);
        }

        function handleSideTelopPresetSnapshot(snapshot) {
          const payload = typeof snapshot?.val === 'function' ? snapshot.val() || {} : {};
          const items = Array.isArray(payload?.right?.items) ? payload.right.items : [];
          const activeIndex = Number.isInteger(payload?.right?.activeIndex) ? payload.right.activeIndex : 0;
          const clampedIndex = items.length ? Math.min(Math.max(activeIndex, 0), items.length - 1) : 0;
          const activeText = ensureString(items[clampedIndex] || '') || sideTelopDefaults.right;
          updateSideTelopFallback({ right: activeText });
        }

        function formatScheduleDate(schedule) {
          const normalized = ensureString(schedule.date || schedule.scheduleDate);
          if (!normalized) return '';
          const match = normalized.match(/^(\d{4})[-/.]?(\d{1,2})[-/.]?(\d{1,2})/);
          if (!match) return normalized;
          const [, y, m, d] = match;
          const year = Number(y);
          const month = Number(m);
          const day = Number(d);
          if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return normalized;
          const date = new Date(Date.UTC(year, month - 1, day));
          const weekday = ['日', '月', '火', '水', '木', '金', '土'][date.getUTCDay()];
          return `${year}.${month}/${day}(${weekday})`;
        }

        function parseDateTime(text) {
          const match = ensureString(text).match(/^(\d{4})-(\d{2})-(\d{2})[T ]?(\d{2}):(\d{2})/);
          if (!match) return null;
          const [, y, m, d, hh, mm] = match;
          const year = Number(y);
          const month = Number(m);
          const day = Number(d);
          const hour = Number(hh);
          const minute = Number(mm);
          if ([year, month, day, hour, minute].some((v) => !Number.isFinite(v))) return null;
          const weekday = ['日', '月', '火', '水', '木', '金', '土'][
            new Date(Date.UTC(year, month - 1, day)).getUTCDay()
          ];
          return { year, month, day, hour, minute, weekday };
        }

        function formatDateWithWeekday(parts) {
          if (!parts) return '';
          const { year, month, day, weekday } = parts;
          return `${year}.${month}/${day}(${weekday})`;
        }

        function formatCrossDateWithWeekday(parts) {
          if (!parts) return '';
          const { month, day, weekday } = parts;
          return `${month}/${day}(${weekday})`;
        }

        function formatTime(parts) {
          if (!parts) return '';
          const { hour, minute } = parts;
          return `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        }

        function formatScheduleText(schedule = {}, fallbackLabel = '') {
          const parsedStart = parseDateTime(schedule.startAt || schedule.startTime);
          const parsedEnd = parseDateTime(schedule.endAt || schedule.endTime);
          const dateText = parsedStart ? formatDateWithWeekday(parsedStart) : formatScheduleDate(schedule);
          let dated = dateText;

          if (parsedStart && parsedEnd) {
            const sameDate =
              parsedStart.year === parsedEnd.year &&
              parsedStart.month === parsedEnd.month &&
              parsedStart.day === parsedEnd.day;
            const endDateText = sameDate
              ? ''
              : `${formatCrossDateWithWeekday(parsedEnd)}${formatTime(parsedEnd)}`;
            const range = `${formatTime(parsedStart)}〜${sameDate ? formatTime(parsedEnd) : endDateText}`;
            dated = `${dateText} ${range}`.trim();
          } else if (parsedStart) {
            const timeRange = formatTime(parsedStart);
            dated = [dateText, timeRange].filter(Boolean).join(' ').trim();
          } else if (parsedEnd) {
            const timeRange = formatTime(parsedEnd);
            dated = [dateText, timeRange].filter(Boolean).join(' ').trim();
          }

          const label = ensureString(schedule.label) || ensureString(fallbackLabel);
          return dated || label;
        }

        async function refreshSideTelopFallbackFromMeta(eventId, scheduleId) {
          const normalizedEvent = ensureString(eventId);
          if (!normalizedEvent) {
            return;
          }
          const token = ++sideTelopMetaToken;
          try {
            const [eventSnap, scheduleSnap] = await Promise.all([
              get(ref(database, `questionIntake/events/${normalizedEvent}`)),
              scheduleId ? get(ref(database, `questionIntake/schedules/${normalizedEvent}/${scheduleId}`)) : Promise.resolve(null)
            ]);
            if (token !== sideTelopMetaToken) return;
            if (!eventSnap?.exists()) return;
            const eventData = eventSnap.val() || {};
            const eventName = ensureString(eventData.name);
            const schedule = scheduleSnap && typeof scheduleSnap.val === 'function' && scheduleSnap.exists()
              ? scheduleSnap.val() || {}
              : {};
            const scheduleText = formatScheduleText(schedule);
            const nextLeft = eventName && scheduleText ? `${eventName}\n${scheduleText}` : '';
            updateSideTelopFallback({ left: urlSideLeft || nextLeft });
          } catch (err) {
            logDisplayLinkWarn('Failed to fetch event metadata for side telops', err);
          }
        }

        applySideTelops();

        function handleNowShowingSnapshot(snapshot) {
          const telopData  = snapshot.val() || null;
          const name       = telopData?.name ?? '';
          const question   = telopData?.question ?? '';
          const genre      = telopData?.genre != null ? String(telopData.genre) : '';
          const uid        = telopData?.uid ? String(telopData.uid) : '';
          const participantId = telopData?.participantId ? String(telopData.participantId) : '';
          const pickup     = telopData?.pickup === true;
          const hasQuestion = !!(question && question.trim().length);

          applySideTelops(telopData || {});

          if (!hasQuestion){
            logDisplayLinkInfo('Received nowShowing clear request', {
              eventId: channelEventId || null,
              scheduleId: channelScheduleId || null,
              previousName: prevName || null
            });
          } else {
            logDisplayLinkInfo('Received nowShowing payload', {
              eventId: channelEventId || null,
              scheduleId: channelScheduleId || null,
              uid: uid || null,
              participantId: participantId || null,
              pickup,
              name,
              hasGenre: !!genre
            });
          }

          if (!hasQuestion){
            // 非表示へ（座布団ごと退場）…中身は退場完了後に消す
            pendingClear = true;
            hideTelop();
            return;
          }
    
          // ラベル制御（Pick Up Question はラベル非表示）※ ここでは切り替え“しない”
          const isPickup = (n, flag) => flag === true || String(n).trim().toLowerCase().replace(/\s+/g,'') === 'pickupquestion';
          const willNoLabel = isPickup(name, pickup);
          // ★ nowShowing 更新時に前回値との差分を把握して、必要なDOMだけを入れ替える
          const nameChanged  = name.trim() !== prevName.trim();
          const qChanged     = question.trim() !== prevQuestion.trim();
          const prevGenreTrim = prevGenre.trim();
          const genreTrim   = genre.trim();
          const genreChanged = genreTrim !== prevGenreTrim;
          const labelChanged = (radioNameEl.classList.contains('no-label') !== willNoLabel);
          const nameOrLabelChanged = nameChanged || labelChanged;
          const hadGenre = prevGenreTrim.length > 0;
          const hasGenre = genreTrim.length > 0;
          const myToken     = ++updateToken;  // 後着優先

          // 座布団自体は出す（入場アニメは showTelop が担当）
          if (telopCanvas.classList.contains('hidden')) {
            // 初回は next を渡して入場（座布団サイズは telopIn アニメで表示）
            const next = { name, question, genre, noLabel: willNoLabel, uid, participantId, pickup };
            // 初回でも本文は先に適用してOK（入場はクラスで実施）
            radioNameEl.textContent = name;
            const genreText = genre.trim();
            genreValueEl.textContent = genreText;
            genrePanelEl.classList.toggle('is-empty', !genreText);
            questionEl.innerHTML    = applyRuby(question);
            radioNameEl.classList.toggle('no-label', willNoLabel);
            showTelop(next);
          } else {
            // 表示中：変化した要素を同時にフェードアウト
            const outs = [];
            if (nameOrLabelChanged) outs.push(fadeOut(radioNameEl));
            if (genreChanged && hadGenre) outs.push(fadeOut(genrePanelEl));
            if (qChanged)           outs.push(fadeOut(questionEl));
            if (outs.length){
              Promise.all(outs).then(async ()=>{
                if (myToken !== updateToken) return; // レース対策
                const next = { name, question, genre, noLabel: willNoLabel, uid, participantId, pickup };

                // ★ 変更開始＝showing（phase と updatedAt を更新）
                const showingPayload = { name, question };
                if (uid) showingPayload.uid = uid;
                if (participantId) showingPayload.participantId = participantId;
                if (pickup) showingPayload.pickup = true;
                if (genre) showingPayload.genre = genre;
                reportRender('showing');

                await fontsReady();
                await flipResize(next);              // サイズ補間（座布団も滑らか）
                if (myToken !== updateToken) return; // レース対策

                // テキストはクロスフェードで復帰
                if (nameOrLabelChanged) fadeIn(radioNameEl);
                if (genreChanged && hasGenre) fadeIn(genrePanelEl);
                if (qChanged)           fadeIn(questionEl);
                ensureTextVisible();

                // ★ 反映完了＝visible（nowShowing と updatedAt を確定）
                const visiblePayload = { name, question };
                if (uid) visiblePayload.uid = uid;
                if (participantId) visiblePayload.participantId = participantId;
                if (pickup) visiblePayload.pickup = true;
                if (genre) visiblePayload.genre = genre;
                reportRender('visible');
              });
            } else {
              // 変更なしでも不可視が残っていたら強制復帰
              ensureTextVisible();
              // // 同一内容の再通知でも更新時刻を刻みたいなら↓を有効化
              // reportRender('visible', { nowShowing: { name, question } });
            }
          }
          prevName = name; prevQuestion = question; prevGenre = genre;
        }

        function subscribeNowShowing() {
          if (typeof nowShowingUnsubscribe === 'function') {
            nowShowingUnsubscribe();
          }
          const path = getNowShowingPath(channelEventId, channelScheduleId);
          logDisplayLinkInfo('Subscribing nowShowing stream', {
            path,
            eventId: channelEventId || null,
            scheduleId: channelScheduleId || null
          });
          nowShowingUnsubscribe = onValue(nowShowingRef, handleNowShowingSnapshot);
        }

        function subscribeSideTelops() {
          if (typeof sideTelopUnsubscribe === 'function') {
            sideTelopUnsubscribe();
          }
          const path = getSideTelopPath(channelEventId, channelScheduleId);
          logDisplayLinkInfo('Subscribing sideTelop stream', {
            path,
            eventId: channelEventId || null,
            scheduleId: channelScheduleId || null
          });
          sideTelopUnsubscribe = onValue(sideTelopRef, handleSideTelopPresetSnapshot, (error) => {
            logDisplayLinkWarn('Failed to subscribe sideTelop stream', error);
          });
        }
  </script>
</body>
</html>
